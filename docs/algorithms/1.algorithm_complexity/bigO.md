算法复杂度
===

**讲解算法的基础知识**

---

## 为什么需要算法复杂度

计算机是一种工具,我们如何评估计算机的效率,确定那些问题可以采用计算机来解决。
为了评估这些问题,产生了复杂度分析的概念。算法复杂度就是用来评估计算机复杂性的一种手段。这里的复杂度主要指两个方面:

* **时间复杂度** 是指代码运行的时长评估
* **空间复杂度** 是指代码运行的内存评估

## 时间复杂度分析

代码的运行时间会受多个因素的影响。所以无法精确评估每一段代码的执行时间。为了对代码的执行时间进行估算,时间复杂度经过了如下的抽象过程。

1. 将代码的执行抽象为一系列基本操作,
并假设所有基本操作运行均为单位时间 t.
2. 根据上述抽象,假设运行总时间为所有基本操作次数 n*t
3. 将代码的执行次数转换为和数据量 n 有关的函数,得到代码的中执行时间为 `T = f(n)*t`
4. 为了进一步表述代码的执行时间和数据量 n 的变化关系,则只关心影响 n 变化的最大因子,而这里就抽象出了大 O 表示法。

下面以一个例子详细讲解该过程。假设如下的代码

```js
let sum= 0;
let n = 10;
for(let i=0;i<=n;i++) {
 sum+=i
}
```

该代码用于求取 1到10的累加和。由于代码有一系列语句组成。
这里我们提炼如下的基本操作

1. 赋值表达式
2. 计算语句,包括自加操作,
3. 调用操作 ...

则统计的语句总次数如下

```js
let sum= 0; // 声明赋值语句 1 次
let n = 10; // 声明赋值语句 1 次
for(let i=0;i<=n;i++) { // 声明语句 1 一次,判断语句 i<=n 执行 n 次,i++ 执行 n 次
 sum+=i; // 自加语句执行 n 次
}
```

根据上述总执行次数得出代码的操作次数 为 `1+1+1+n+n+n=3n+3` 执行时间为 `3n+3`*t,再把 n 换为 10 即可估算运行总时间。

> 上述估算并不精确,实际上不同语句的执行时间并不相同,但是这里的估算提供了
> 一种快速分析算法计算时间的简化模型

我们可以讲上述公式表示为 `T = f(3n+4)*t` 公式含义如下

* `T` 代码执行时间
* `f(3n+4)` 表示代码的执行总次数和 n 的关系
* t 表示单位操作的执行时间

进一步分析,当 n 趋向无穷大时,此时为了分析执行时间和系数 n 的关系。可以表述为如下格式 T = O(n)。

该表示的含义是时间和数据量的增长之间呈线性关系。

> 注意大 O 表示法的意义是为了分析代码执行时间,在数据量增长时的增长趋势,而非计算具体时间,我们的重点是研究它增长趋势,所以可以忽略增长的系数,而只关心**变化趋势的形态**

## 典型的大 O 函数

基于此典型的大 O 模型包含如下几种

* `O(1)` 常量型,表示数据量增大并不会导致执行时间的增长任然是有限的执行次数
* `O(lgn)` 对数型
* `O(n)` 线性复杂度
* `O(nlgn)`
* `O(n^2)`

## 相关资料

* [算法复杂度概述](http://discrete.gr/complexity/)

### 交互示例（fenced 语法）

下方示例使用 fenced 语法插入 Playground。未显式指定 `file/dir/files` 时，将默认查找当前文档同级目录下的 `./playground/`。

```playground
title: "时间复杂度趋势演示"
template: react
entry: App.jsx
options:
  editable: false
  runOnLoad: true
```

> 说明：默认目录规则使得每个文档可就近放置 `playground/` 示例，便于组织与维护。
