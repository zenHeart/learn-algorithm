# 硬币找零

## 解题思路

<!--TODO: 为什么会想到动态规划 -->

采用动态规划，拆分子问题。总面额对应的最少硬币数,可通过求取总面额减去各银币金额对应的新的总面额在加上 1(由于减去了一枚银币)中最小值得到。而新的总面额可继续通过上述方法求取。抽象为如下公式:

- `a` 表示总面额
- `c1,c2...` 表示不同面额的硬币
- `n(a)` 表示总面额为 a 时对应的最少硬币数的解

则对 n(a) 的求解为:

> n(a) = Min{ n(a-c<sub>i</sub>) + 1 } (i=1,2,3...)

假设上述步骤求得的最佳结果为 n(a - c<sub>x</sub>) 则可进一步求解

> n(a - c<sub>x</sub>) = Min{ n(a-c<sub>x</sub> - c<sub>i</sub>) + 1) }(x≥1, i=1,2,...)

基于上述逻辑得到如下伪代码

```
coinChange(coins,amount) {
    // 初始化空数组保存结果
    mins = [];

    // 循环查找硬币
    for coin in coins
        // 得到减去 coin 面额后对应总金额的解
        newMins = coinChange(coins,amount - coin )

        //取当前解和 newMins + 1 更小的值作为新的 mins
        mins = Min(min,newMins+1)

    // 返回最终结果即可
    return mins;
}
```

## 答案分析

leetcode 解题笔记

1. 若代码出现超时,需要利用缓存函数,避免结果反复计算
2. 若利用缓存函数出现类似用例不通过,是因为 leetcode 测试用例使用多种类型的输入,而缓存必须只针对特定的输入,所当判断输入的硬币数不同时需清空缓存,避免缓存错误导致的提交失败
