# 递归建模专项训练计划

目标：帮助你从会写单个算法模板，进阶到能够**在任意复杂结构问题中第一时间抽象出递归模型和状态传递**，能快速实现像 `flatten`、序列化、路径统计、组合搜索这类题目，并在面试或实战中迅速选型与编码。

---

## 总体学习结构（5 个阶段）

1. **阶段 1 — 递归与 DFS 模板化（基础）**
2. **阶段 2 — 带状态的 DFS（路径/上下文传递）**
3. **阶段 3 — 回溯与决策树（组合/剪枝/撤销）**
4. **阶段 4 — 结构建模训练（从问题到模型的速写能力）**
5. **阶段 5 — 提速与工程化（模版库、套路复用、读取面试题）**

每个阶段包含：学习目标、必备知识点、练习题、示例/提示、检查表与进阶任务。

---

# 阶段 1 — 递归与 DFS 模板化（基础）

**目标**：牢固掌握递归/DFS 的最基本模式；能用最少错误写出前序/中序/后序、树/图的遍历代码。

**知识点**：

* 递归三要素：边界条件、递推式（子问题）、单层操作
* 调用栈与隐式状态（函数参数、局部变量）
* 树与图的节点/邻接关系
* 终止条件与空值检查（null、undefined）

**练习题（从易到中）**：

1. 实现二叉树的前/中/后序遍历（递归与迭代两种）
2. 给定文件夹结构对象，输出所有文件路径（不记录空文件夹）
3. 给定图的邻接表，做 DFS 并返回访问顺序（防止环）

**示例提示**：

* 练习 2 的关键是：把"路径"当作字符串或数组在递归中传递，只有在叶子（文件）处输出。
* 练习 3 的关键：维护 `visited` 集合以避免重复访问。

**检查表**：

* [ ] 能复述递归三要素
* [ ] 写出前中后序模板 3 行以内
* [ ] 能解释调用栈上变量的生命周期

**进阶任务**：实现 `traverse(value, visit, path=[])` 的通用遍历器（支持对象/数组/基本类型）。

---

# 阶段 2 — 带状态的 DFS（路径/上下文传递）

**目标**：学会在递归中显式传递并构造上下文（路径、累加值、统计信息），并用它解决序列化、flatten 等问题。

**知识点**：

* 状态传递 vs 隐式栈
* 不可变参数（通过 `concat`/展开创建新数组/字符串）与可变参数（push/pop）的利弊
* 何时使用外部结果容器（如 `res`） vs 返回值合并

**练习题**：

1. 实现 `flatten`（题主问题）：键格式 `a.b`, 数组格式 `b[0]`。
2. 把嵌套对象序列化为 query string（例如 `a[b]=1&a[c]=2`）
3. 打印所有从根到叶的路径（路径以数组形式返回）

**示例提示**：

* 对于 `flatten`，先画出递归树，明确节点与子节点；路径应作为参数并以 `.` 与 `[i]` 规则拼接。
* 对于路径集合，使用可变 `path` + `push/pop` 能减少内存分配，但要小心 `pop` 的位置。

**检查表**：

* [ ] 能解释何时用不可变 `path.concat()`，何时用 `push/pop`
* [ ] 能写出 `flatten` 的正确实现并考虑 `null` 与循环引用（可选）

**进阶任务**：把 `traverse` 函数抽象成通用工具，并用它实现以上所有题目。

---

# 阶段 3 — 回溯与决策树（组合/剪枝/撤销）

**目标**：掌握回溯的精髓：如何在递归中“做选择、检验、撤销选择”，以及如何设计有效的剪枝策略。

**知识点**：

* 回溯 vs 状态型DFS 的本质差别（目标是“搜索满足条件的解”）
* 状态做“选择”与“撤销”（push/pop 模式）
* 剪枝技巧：排序 + 界限检查 + 哈希去重 + 估价函数
* 使用启发式（heuristic）进行早期停止

**练习题**：

1. 全排列（含重复元素去重）
2. 组合求和（组合总和类题）
3. N 皇后（回溯与位运算优化）

**示例提示**：

* 写组合问题时，先做 `for (i = start; i < n; i++)` 的循环，每次 push，递归，pop。
* 剪枝：在组合求和，把数组排序并在循环中 `if (curr > target) break`。

**检查表**：

* [ ] 能写出含剪枝的回溯模板并解释为什么能减小复杂度
* [ ] 能在面试中把回溯题拆解为 "选择集合、约束、目标" 三部分

**进阶任务**：把常用剪枝模式写成小函数（如 `canPrune(state)`），并在多道题里复用。

---

# 阶段 4 — 结构建模训练（从问题到模型的速写能力）

**目标**：训练从自然语言问题快速抽取“递归模型”和“需要传递的状态”，在 1–3 分钟之内写出递归框架代码。

**知识点**：

* 问题分类技巧（遍历/路径构造/聚合/搜索/最优解）
* 结构化速记：三个问题——节点、边界、状态
* 常见状态模式：`path`（路径）、`accumulator`（累加）、`count`（计数）、`choices`（当前选择集合）

**练习流程（练习集）**：

* 步骤 A：读题 30s，总结节点/边界/状态
* 步骤 B：画一棵小的递归树示例（手绘或纸上）
* 步骤 C：写伪代码并实现

**每日题单（7 天）**：

* Day1: flatten / serialize / print paths
* Day2: 文件夹统计（文件总数/最大深度）
* Day3: JSON schema 校验（验证必需字段）
* Day4: 最长根到叶路径值（和/串联）
* Day5: 从嵌套对象中提取所有满足条件的节点（过滤）
* Day6: 图的所有简单路径（有环需去重）
* Day7: 综合演练（4 道题，限时 20 分钟）

**示例提示**：

* 练习时严格执行 A->B->C 三步骤，不开编辑器先用纸或注释写伪代码。

**检查表**：

* [ ] 能在 3 分钟内把题目抽象成“节点/边界/状态”三要点
* [ ] 能在 10 分钟内写出可运行的递归框架（不需要细节完备）

---

# 阶段 5 — 提速与工程化（模版库、套路复用、面试技巧）

**目标**：把常用的递归/回溯模板固化为个人工具库，并训练在面试中快速应用（做到 1–5 分钟内完成框架编码，10–20 分钟内完成题解）。

**知识点**：

* 模版化代码片段（纯 DFS、带 path、带回溯的 push/pop）
* 如何写出清晰的伪代码给面试官（明确输入/输出、复杂度）
* 性能陷阱（大量对象合并导致的内存、递归深度导致的栈溢出）

**练习/任务**：

1. 把 `traverse`、`flatten`、`unflatten`、`permutation`、`combination` 模块化成 snippet 并保存在代码片段管理器（VSCode snippets）
2. 每周做 2 道限时题（40 分钟内）并写复盘：模型如何建立、为何选择这种状态、复杂度分析
3. 学会写小型 benchmark：测试 `push/pop` 与 `concat` 在你的目标数据规模下的性能

**检查表**：

* [ ] 已有至少 5 个可复用代码片段
* [ ] 能在白板上向他人讲解 3 个递归/回溯模板

---

# 附：题目清单（含难度分级与关键提示）

## 基础（⭐）

* 二叉树前中后序遍历（提示：递归三要素）
* 目录扁平化（提示：把文件当叶子）

## 中级（⭐⭐）

* JSON flatten（本次核心题） — **提示**：节点 = 对象 key 或数组索引；状态 = `path`（字符串/数组）
* 打印所有从根到叶的路径（提示：在叶子处 `push([...path])`）

## 进阶（⭐⭐⭐）

* 全排列（含重复元素去重） — **提示**：使用排序 + `used` 数组
* 组合求和（带剪枝） — **提示**：排序 + 剪枝 `if (sum > target) break`
* N 皇后（回溯 + 位运算优化）

## 挑战（⭐⭐⭐⭐）

* 图中所有简单路径（有向/无向，有环需去重）
* 从嵌套对象中批量提取并重构（包含数组/对象混合）

---

# 每日/每周训练计划（推荐 6 周路线）

* 周 1：阶段 1（基础题与 `traverse` 抽象）
* 周 2：阶段 2（flatten、serialize、路径题）
* 周 3-4：阶段 3（回溯题 + 剪枝）
* 周 5：阶段 4（速写训练 + 每日限时题）
* 周 6：阶段 5（模板化 + 复盘 + 面试模拟）

每周目标：完成 8–12 道练习题并写 3 次复盘。

---

# 复盘模版（每道题都要写）

1. 题目描述（来源）
2. 模型抽象：节点 / 边界 / 需要传递的状态
3. 伪代码框架
4. 复杂度分析
5. 优化点与边界（内存、特殊值）
6. 反思（3 点）

---

# 小贴士（写代码时的速成 check list）

1. 先写伪代码（1–2 行），不要急着细节化
2. 明确 `node` 和 `children` 如何从题目数据结构映射出来
3. 明确 `state` 类型（可变/不可变）并保持一致
4. 写测试：空值、单元素、深嵌套、循环引用（如果要支持）
5. 面试时把复杂度口头说明在 10 秒内

---

# 结语

按照这个计划练习 6 周，你会从“知道算法样子”进阶为“在任意复杂结构题里快速构建递归模型”的工程能力。若你愿意，我可以：

* 把本计划拆成每日任务并生成练习题（可导出为 markdown 或 Todo 列表）；
* 为你自动生成 `traverse` / `flatten` / `unflatten` 等代码片段并放到一个可复制的代码文件里；
* 跟你做 4 周的训练复盘，每周点评一次解法。
